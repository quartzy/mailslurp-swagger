<?php
/**
 * InboxControllerApi
 * PHP version 5
 *
 * @category Class
 * @package  MailSlurp\Swagger
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * MailSlurp API Documentation
 *
 * [MailSlurp](https://www.mailslurp.com) is an end-to-end email testing service. It has a [web-app](https://www.mailslurp.com/dashboard) for managing your account and a [REST API](https://api.mailslurp.com) for sending and receiving emails from randomly generated email addresses.  ## Why? MailSlurp was built to test the integration of email services within an app. If your application relies on the sending or receiving of emails, then MailSlurp will let you test that functionality. This is a more common need than you might think: if your app has a sign up process that requires email verification, how do you currently test that?  ## Getting started - [API Docs](https://www.mailslurp.com/documentation) - [Code Examples](https://www.mailslurp.com/documentation/examples) - [Swagger Definition](https://api.mailslurp.com/v2/api-docs)  Every API request requires a valid API Key appended as a query parameter. [To obtain an API Key visit your account dashboard](https://www.mailslurp.com/dashboard).    The general flow is as follows:  - Create a new inbox during a test. The email address will be returned in the response.  - Send an email to that address or trigger an action in your test that does so. - Fetch the email for your new inbox and check if its content is what you expected, or use the content in another action.  ## SDK - There is an official [Javascript SDK](https://www.npmjs.com/package/mailslurp-client) available on npm. - You can also use the [swagger JSON definition](https://api.mailslurp.com/v2/api-docs) and [swagger-codegen](https://github.com/swagger-api/swagger-codegen) to generate a swagger client in a language of your choice.  ## Legal The Mailslurp API code is owned by [PettmanUG](http://pettmanug.site) and uses a proprietary [software licence](http://www.binpress.com/license/view/l/c8376a01eca7465027a978d3fde5a1e2). The SDKs are free to use in any project and have an ISC licence.  ## Bugs, features, support To report bugs or request features please see the [contact page](https://www.mailslurp.com/contact). For help see [support](https://www.mailslurp.com/support).
 *
 * OpenAPI spec version: 0.0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace MailSlurp\Swagger\MailSlurp\Swagger\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use MailSlurp\Swagger\ApiException;
use MailSlurp\Swagger\Configuration;
use MailSlurp\Swagger\HeaderSelector;
use MailSlurp\Swagger\ObjectSerializer;

/**
 * InboxControllerApi Class Doc Comment
 *
 * @category Class
 * @package  MailSlurp\Swagger
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class InboxControllerApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createRandomInboxUsingPOST
     *
     * Create an inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseInboxDto_
     */
    public function createRandomInboxUsingPOST($apiKey)
    {
        list($response) = $this->createRandomInboxUsingPOSTWithHttpInfo($apiKey);
        return $response;
    }

    /**
     * Operation createRandomInboxUsingPOSTWithHttpInfo
     *
     * Create an inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseInboxDto_, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRandomInboxUsingPOSTWithHttpInfo($apiKey)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseInboxDto_';
        $request = $this->createRandomInboxUsingPOSTRequest($apiKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseInboxDto_',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRandomInboxUsingPOSTAsync
     *
     * Create an inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRandomInboxUsingPOSTAsync($apiKey)
    {
        return $this->createRandomInboxUsingPOSTAsyncWithHttpInfo($apiKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRandomInboxUsingPOSTAsyncWithHttpInfo
     *
     * Create an inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRandomInboxUsingPOSTAsyncWithHttpInfo($apiKey)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseInboxDto_';
        $request = $this->createRandomInboxUsingPOSTRequest($apiKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRandomInboxUsingPOST'
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createRandomInboxUsingPOSTRequest($apiKey)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling createRandomInboxUsingPOST'
            );
        }

        $resourcePath = '/inboxes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiKey !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($apiKey);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteInboxUsingDELETE
     *
     * Delete an inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Swagger\MailSlurp\Swagger\Model\Response
     */
    public function deleteInboxUsingDELETE($apiKey, $uuid)
    {
        list($response) = $this->deleteInboxUsingDELETEWithHttpInfo($apiKey, $uuid);
        return $response;
    }

    /**
     * Operation deleteInboxUsingDELETEWithHttpInfo
     *
     * Delete an inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Swagger\MailSlurp\Swagger\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteInboxUsingDELETEWithHttpInfo($apiKey, $uuid)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\Response';
        $request = $this->deleteInboxUsingDELETERequest($apiKey, $uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Swagger\MailSlurp\Swagger\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteInboxUsingDELETEAsync
     *
     * Delete an inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboxUsingDELETEAsync($apiKey, $uuid)
    {
        return $this->deleteInboxUsingDELETEAsyncWithHttpInfo($apiKey, $uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteInboxUsingDELETEAsyncWithHttpInfo
     *
     * Delete an inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteInboxUsingDELETEAsyncWithHttpInfo($apiKey, $uuid)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\Response';
        $request = $this->deleteInboxUsingDELETERequest($apiKey, $uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteInboxUsingDELETE'
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteInboxUsingDELETERequest($apiKey, $uuid)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling deleteInboxUsingDELETE'
            );
        }
        // verify the required parameter 'uuid' is set
        if ($uuid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling deleteInboxUsingDELETE'
            );
        }

        $resourcePath = '/inboxes/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiKey !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($apiKey);
        }

        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getEmailsForInboxUsingGET
     *
     * Fetch emails for a given inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  int $minCount Wait a maximum of 60 seconds for atleast this many emails in an inbox before returning a result. (optional)
     * @param  int $maxWait Maximum seconds API should spend retrying your inbox until the minCount is satisfied (optional)
     * @param  \DateTime $since Filter for emails received on or after this ISO8601 LocalDateTime. (optional)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListEmailDto_
     */
    public function getEmailsForInboxUsingGET($apiKey, $uuid, $minCount = null, $maxWait = null, $since = null)
    {
        list($response) = $this->getEmailsForInboxUsingGETWithHttpInfo($apiKey, $uuid, $minCount, $maxWait, $since);
        return $response;
    }

    /**
     * Operation getEmailsForInboxUsingGETWithHttpInfo
     *
     * Fetch emails for a given inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  int $minCount Wait a maximum of 60 seconds for atleast this many emails in an inbox before returning a result. (optional)
     * @param  int $maxWait Maximum seconds API should spend retrying your inbox until the minCount is satisfied (optional)
     * @param  \DateTime $since Filter for emails received on or after this ISO8601 LocalDateTime. (optional)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListEmailDto_, HTTP status code, HTTP response headers (array of strings)
     */
    public function getEmailsForInboxUsingGETWithHttpInfo($apiKey, $uuid, $minCount = null, $maxWait = null, $since = null)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListEmailDto_';
        $request = $this->getEmailsForInboxUsingGETRequest($apiKey, $uuid, $minCount, $maxWait, $since);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListEmailDto_',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getEmailsForInboxUsingGETAsync
     *
     * Fetch emails for a given inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  int $minCount Wait a maximum of 60 seconds for atleast this many emails in an inbox before returning a result. (optional)
     * @param  int $maxWait Maximum seconds API should spend retrying your inbox until the minCount is satisfied (optional)
     * @param  \DateTime $since Filter for emails received on or after this ISO8601 LocalDateTime. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailsForInboxUsingGETAsync($apiKey, $uuid, $minCount = null, $maxWait = null, $since = null)
    {
        return $this->getEmailsForInboxUsingGETAsyncWithHttpInfo($apiKey, $uuid, $minCount, $maxWait, $since)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getEmailsForInboxUsingGETAsyncWithHttpInfo
     *
     * Fetch emails for a given inbox
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  int $minCount Wait a maximum of 60 seconds for atleast this many emails in an inbox before returning a result. (optional)
     * @param  int $maxWait Maximum seconds API should spend retrying your inbox until the minCount is satisfied (optional)
     * @param  \DateTime $since Filter for emails received on or after this ISO8601 LocalDateTime. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getEmailsForInboxUsingGETAsyncWithHttpInfo($apiKey, $uuid, $minCount = null, $maxWait = null, $since = null)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListEmailDto_';
        $request = $this->getEmailsForInboxUsingGETRequest($apiKey, $uuid, $minCount, $maxWait, $since);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getEmailsForInboxUsingGET'
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  int $minCount Wait a maximum of 60 seconds for atleast this many emails in an inbox before returning a result. (optional)
     * @param  int $maxWait Maximum seconds API should spend retrying your inbox until the minCount is satisfied (optional)
     * @param  \DateTime $since Filter for emails received on or after this ISO8601 LocalDateTime. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getEmailsForInboxUsingGETRequest($apiKey, $uuid, $minCount = null, $maxWait = null, $since = null)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling getEmailsForInboxUsingGET'
            );
        }
        // verify the required parameter 'uuid' is set
        if ($uuid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling getEmailsForInboxUsingGET'
            );
        }

        $resourcePath = '/inboxes/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiKey !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($apiKey);
        }
        // query params
        if ($minCount !== null) {
            $queryParams['minCount'] = ObjectSerializer::toQueryValue($minCount);
        }
        // query params
        if ($maxWait !== null) {
            $queryParams['maxWait'] = ObjectSerializer::toQueryValue($maxWait);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = ObjectSerializer::toQueryValue($since);
        }

        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getListOfInboxesUsingGET
     *
     * List your inboxes
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListInboxDto_
     */
    public function getListOfInboxesUsingGET($apiKey)
    {
        list($response) = $this->getListOfInboxesUsingGETWithHttpInfo($apiKey);
        return $response;
    }

    /**
     * Operation getListOfInboxesUsingGETWithHttpInfo
     *
     * List your inboxes
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListInboxDto_, HTTP status code, HTTP response headers (array of strings)
     */
    public function getListOfInboxesUsingGETWithHttpInfo($apiKey)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListInboxDto_';
        $request = $this->getListOfInboxesUsingGETRequest($apiKey);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListInboxDto_',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getListOfInboxesUsingGETAsync
     *
     * List your inboxes
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListOfInboxesUsingGETAsync($apiKey)
    {
        return $this->getListOfInboxesUsingGETAsyncWithHttpInfo($apiKey)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getListOfInboxesUsingGETAsyncWithHttpInfo
     *
     * List your inboxes
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getListOfInboxesUsingGETAsyncWithHttpInfo($apiKey)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\ResponseListInboxDto_';
        $request = $this->getListOfInboxesUsingGETRequest($apiKey);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getListOfInboxesUsingGET'
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getListOfInboxesUsingGETRequest($apiKey)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling getListOfInboxesUsingGET'
            );
        }

        $resourcePath = '/inboxes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiKey !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($apiKey);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation sendEmailFromUserUsingPOST
     *
     * Send an email
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  \MailSlurp\Swagger\MailSlurp\Swagger\Model\SendEmailDto $sendEmailDto The email to send. (required)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \MailSlurp\Swagger\MailSlurp\Swagger\Model\Response
     */
    public function sendEmailFromUserUsingPOST($apiKey, $uuid, $sendEmailDto)
    {
        list($response) = $this->sendEmailFromUserUsingPOSTWithHttpInfo($apiKey, $uuid, $sendEmailDto);
        return $response;
    }

    /**
     * Operation sendEmailFromUserUsingPOSTWithHttpInfo
     *
     * Send an email
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  \MailSlurp\Swagger\MailSlurp\Swagger\Model\SendEmailDto $sendEmailDto The email to send. (required)
     *
     * @throws \MailSlurp\Swagger\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \MailSlurp\Swagger\MailSlurp\Swagger\Model\Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function sendEmailFromUserUsingPOSTWithHttpInfo($apiKey, $uuid, $sendEmailDto)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\Response';
        $request = $this->sendEmailFromUserUsingPOSTRequest($apiKey, $uuid, $sendEmailDto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\MailSlurp\Swagger\MailSlurp\Swagger\Model\Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation sendEmailFromUserUsingPOSTAsync
     *
     * Send an email
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  \MailSlurp\Swagger\MailSlurp\Swagger\Model\SendEmailDto $sendEmailDto The email to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendEmailFromUserUsingPOSTAsync($apiKey, $uuid, $sendEmailDto)
    {
        return $this->sendEmailFromUserUsingPOSTAsyncWithHttpInfo($apiKey, $uuid, $sendEmailDto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation sendEmailFromUserUsingPOSTAsyncWithHttpInfo
     *
     * Send an email
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  \MailSlurp\Swagger\MailSlurp\Swagger\Model\SendEmailDto $sendEmailDto The email to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function sendEmailFromUserUsingPOSTAsyncWithHttpInfo($apiKey, $uuid, $sendEmailDto)
    {
        $returnType = '\MailSlurp\Swagger\MailSlurp\Swagger\Model\Response';
        $request = $this->sendEmailFromUserUsingPOSTRequest($apiKey, $uuid, $sendEmailDto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'sendEmailFromUserUsingPOST'
     *
     * @param  string $apiKey Your API Key. Sign up and find it in your dashboard. (required)
     * @param  string $uuid The inbox&#39;s id. (required)
     * @param  \MailSlurp\Swagger\MailSlurp\Swagger\Model\SendEmailDto $sendEmailDto The email to send. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function sendEmailFromUserUsingPOSTRequest($apiKey, $uuid, $sendEmailDto)
    {
        // verify the required parameter 'apiKey' is set
        if ($apiKey === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $apiKey when calling sendEmailFromUserUsingPOST'
            );
        }
        // verify the required parameter 'uuid' is set
        if ($uuid === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling sendEmailFromUserUsingPOST'
            );
        }
        // verify the required parameter 'sendEmailDto' is set
        if ($sendEmailDto === null) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sendEmailDto when calling sendEmailFromUserUsingPOST'
            );
        }

        $resourcePath = '/inboxes/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($apiKey !== null) {
            $queryParams['apiKey'] = ObjectSerializer::toQueryValue($apiKey);
        }

        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($sendEmailDto)) {
            $_tempBody = $sendEmailDto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
